# Домашнее задание к занятию 4. «PostgreSQL»

## Задача 1

Используя Docker, поднимите инстанс PostgreSQL (версию 13). Данные БД сохраните в volume.

![image](screen/1.jpg)

![image](/screen/2.jpg)

Подключитесь к БД PostgreSQL, используя `psql`.

![image](/screen/3.jpg)

Воспользуйтесь командой `\?` для вывода подсказки по имеющимся в `psql` управляющим командам.

**Найдите и приведите** управляющие команды для:

- вывода списка БД,
  
  ![image](/screen/4.jpg)
- подключения к БД,
  
  ![image](/screen/5.jpg)
- вывода списка таблиц,
  
  ![image](/screen/6.jpg)
- вывода описания содержимого таблиц,
  
  ![image](/screen/7.jpg)
- выхода из psql.
  
  ![image](/screen/8.jpg)

## Задача 2

Используя `psql`, создайте БД `test_database`.

![image](/screen/9.jpg)

Изучите [бэкап БД](https://github.com/netology-code/virt-homeworks/tree/virt-11/06-db-04-postgresql/test_data).

Восстановите бэкап БД в `test_database`.

![image](/screen/10.jpg)

Перейдите в управляющую консоль `psql` внутри контейнера.

Подключитесь к восстановленной БД и проведите операцию ANALYZE для сбора статистики по таблице.

![image](/screen/11.jpg)

![image](/screen/12.jpg)

Используя таблицу [pg_stats](https://postgrespro.ru/docs/postgresql/12/view-pg-stats), найдите столбец таблицы `orders` с наибольшим средним значением размера элементов в байтах.

![image](/screen/13.jpg)

**Приведите в ответе** команду, которую вы использовали для вычисления, и полученный результат.

## Задача 3

Архитектор и администратор БД выяснили, что ваша таблица orders разрослась до невиданных размеров и поиск по ней занимает долгое время. Вам как успешному выпускнику курсов DevOps в Нетологии предложили провести разбиение таблицы на 2: шардировать на orders_1 - price>499 и orders_2 - price<=499.

Предложите SQL-транзакцию для проведения этой операции.

Можно ли было изначально исключить ручное разбиение при проектировании таблицы orders?

![image](/screen/14.jpg)

![image](/screen/15.jpg)

По поводу изначального разбиение  по разным таблицам(я так понимаю цель в автоматическом режиме) исходя из цены можно попробывать это сделать через функциональные индексы. Я вижу это в создании родительской таблицы и 2е дочерние которые автоматически будут раскидывать данные в первую  таблицу до 500 во вторую после 500.

## Задача 4

Используя утилиту `pg_dump`, создайте бекап БД `test_database`.

![image](/screen/16.jpg)

Как бы вы доработали бэкап-файл, чтобы добавить уникальность значения столбца `title` для таблиц `test_database`?

я бы добавил в строчку **ALTER TABLE test_database ADD CONSTRAINT unique_title UNIQUE (title);** добавив уникальность столбцу
